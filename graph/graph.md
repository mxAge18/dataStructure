# 定义

类型名称：图(Graph)
数据对象集：G(V, E)是由一个非空的有限顶点集合V和一个有限边集合E组成。
操作集：对于任意G

- Graph Create();
- Graph InterVertex(Graph G, Vertex V); //出入一个顶点到图中
- Graph InterEdge(Graph G, Edge E); // 插入一个边到图中
- void DFS(Graph G, Vertex V); //从顶点V出发，深度优先遍历图G
- void BFS(Graph G, Vertex V); // 从顶点V出发，宽度优先遍历图G
- void ShortestPath(Graph G, Vertex V, int Dist[]); // 计算图中顶点v到其他任意顶点的最短距离
- void MST(Graph G); // 计算图G的最小生成树

## 常见术语

- 无向图（每条边没有固定方向）
- 有向图 （有方向的边）
- 网络 （带权重的图）

## 图的表示

### 邻接矩阵

G[N][N] N个顶点从0到N-1编号
G[i][j] = 1 （i到j有一条边）
        = 0 （没有边）
问题：二维数组标识图，数组是一个对称的，存储一半即可（省空间）；用一个N(N+1)/2的一维数组顺序存储G00 G10 G11 G20 G21 G22 ...
G[i][j]在一维数组的位置：i*(i+1)/2 + j
对于网络，把值标识为权重。

- 方便查看某两个顶点之间是否有边
- 方便找任意一个顶点的所有邻接点（有边相连的顶点）
- 方便计算任意顶点的度（跟这个顶点相连的边的数量叫度，从该点出发叫出度，指向该点叫入度）
  - 无向图，行中所有值为1的个数
  - 有向图，行中为1的为出度，列为入度

- 浪费空间（稀疏的图浪费空间，有大量的0值）
- 浪费时间（只能扫描，查1的个数，对于稀疏的图来讲，就很耗费时间）

### 邻接表

邻接表：G[n]为指针数组，对应矩阵每行一个链表，只存非0的元素

### 深度优先搜索DFS

```c
void DFS(Vertex V) {
    visited[V] = true;
    for (V的每个邻接点W) {
        if !Visited[w] {
            DFS(W);
        }
    }
}
```

- 时间复杂度：
  - 邻接表：O(N+E)
  - 邻接矩阵：O(N^2)

### 广度优先搜索BFS

```c
void BFS(Vertex v) {
    visited[v] = true;
    EnQueue(v, q);
    while(!isEmpte(q)) {
        v = DeQueue(q);
        for (v的每个邻接点 w) {
            if (!visited[w]) {
                visited[w] = true;
                Enqueue(w, q);
            }
        }
    }
}
```

- 连通

如果v到w存在一条路径，则称v和w联通

- 路径：
v到w的路径是一系列顶点的集合{v, v1, v2, v3... vn ..., w};
任意一对相邻的顶点之间都有图中的边；
- 路径的长度：路径中的边数。
- 简单路径：V到w之间的顶点全部都不同
- 回路：起点等于终点
- 连通图：任意两个点都连通。

### 图不连通怎么办？

- 连通分量：无向图的极大连通子图
  - 极大顶点数：再多一个顶点图就不连通了。
  - 极大边数：子图中所有顶点相连的所有边

- 强连通：有向图顶点v和w之间存在双向路径，则称v w 强连通
- 强连通图：任意两顶点之间强连通
- 强连通分量：有向图的极大强连通子图

#### 图不连通情况下遍历所有顶点

```c
void ListComponents(Graph G) {
    for (each V in G) {
        if !visited[V] {
            DFS(V); // or BFS(V);
        }
    }
}
```
