# 算法笔记

## 枚举算法

```c
/**完美立方等式。
 * 形如a3= b3 + c3 + d3的等式被称为完美立方等式。
 * 例如 123= 63 + 83 + 103 。编写一个程序，对任给的正整数N (N≤100)，
 * 寻找所有的四元组(a, b, c, d)，使得a3 = b3 + c3 + d3，其中a,b,c,d 大于 1, 小于等于N，且b<=c<=d。
 * 
 * 输入
 * 一个正整数N (N≤100)。
 * 输出
 * 每行输出一个完美立方。输出格式为:
 * Cube = a, Triple = (b,c,d) 其中a,b,c,d所在位置分别用实际求出四元组值代入。
 * */
void perfect_cube();

/** 输入四个整数:p, e, i和d。 p, e, i分别表示体力、情感和智力 高峰出现的日子。
d是给定的日子，可能小于p, e或 i。
所有给 定日子是非负的并且小于或等于365，所求的日子小于或等于 21252。
输出从给定日子起，下一次三个高峰同一天的日子(距离给定日子的天数)。

 输入样例                                         输出样例
0 0 0 0                                          the next triple peak occurs in 21252 days. 
0 0 0 100                                        the next triple peak occurs in 21152 days. 
5 20 34 325                                      the next triple peak occurs in 19575 days. 
4 5 6 7                                          the next triple peak occurs in 16994 days. 
283 102 23 320                                   the next triple peak occurs in 8910 days. 
203 301 203 40                                   the next triple peak occurs in 10789 days.
*/
void physiological_cycles();


/** 假币问题
 * 有12枚硬币。
 * 其中有11枚真币和1枚假币。
 * 假币和真 币重量不同，但不知道假币比真币轻还是重。
 * 现在， 用一架天平称了这些币三次，告诉你称的结果，
 * 请你 找出假币并且确定假币是轻是重(数据保证一定能找 出来)。
 * 
 * 输入
 * 第一行是测试数据组数。
 * 每组数据有三行，每行表示一次称量的结果。银币标号为 A-L。
 * 每次称量的结果用三个以空格隔开的字符串表示: 天平左边放置的硬币 天平右边放置的硬币 平衡状态。
 * 其中平衡状态用``up'', ``down'', 或 ``even''表示, 
 * 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。
 * 输出 
 * 输出哪一个标号的银币是假币，并说明它比真币轻还是重。
 *  输入样例
 * 1
 * ABCD EFGH even 
 * ABCI EFJK up 
 * ABIJ EFGH even 
 *  输出样例
 * K is the counterfeit coin and it is light.
 * */
void fake_coin();

/** 熄灯问题
 * – 有一个由按钮组成的矩阵, 其中每行有6个按钮, 共5行
 * – 每个按钮的位置上有一盏灯
 * – 当按下一个按钮后, 该按钮以及周围位置
 *      (上边, 下边, 左 边, 右边)的灯都会改变状态
 * – 如果灯原来是点亮的, 就会被熄灭 
 * – 如果灯原来是熄灭的, 则会被点亮
 * 给定矩阵中每盏灯的初始状态，求一种按按钮方案
 * 使得所有 的灯都熄灭
 * 
 * 
 *  输入:
 * – 第一行是一个正整数N, 表示需要解决的案例数 
 * – 每个案例由5行组成, 每一行包括6个数字
 * – 这些数字以空格隔开, 可以是0或1
 * – 0 表示灯的初始状态是熄灭的
 * – 1 表示灯的初始状态是点亮的
 * 
 * 
 *  输出:
 * – 对每个案例, 首先输出一行,输出字符串 “PUZZLE #m”, 其中m是该案例的序 号
 * – 接着按照该案例的输入格式输出5行
 * • 1 表示需要把对应的按钮按下
 * • 0 表示不需要按对应的按钮
 * • 每个数字以一个空格隔开
 * */
void close_lights();
```

## 递归

/**

 \* 递归的作用

 \* 1）替代多重循环

 \* 2）解决本来就是用递归形式定义的问题

 \* 3）将问题分解为规模更小的子问题进行求解

 *

*/

### 汉诺塔问题

/**

 \*  汉诺塔问题(Hanoi)

 \* 古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，

 \* 大的在下，小的在上。

 \* 有一个和尚想把这64个盘子从A座移到C座，但每次只能允许移动一个盘子，并且在移动过程中，

 \* 3个座上的盘子始终保持大盘在下，小盘在上。在移动过程中可以利用B座，要求输出移动的步骤。

*/

![Hanoi](assets/20210731-112625@2x.png)



### N皇后问题

- n皇后问题:输入整数n, 要求n个国际象棋的皇后，摆在 n*n的棋盘上，互相不能攻击，输出全部方案。

输入一个正整数N，则程序输出N皇后问题的全部摆法。

输出结果里的每一行都代表一种摆法。行里的第i个数字如果是n，就代表第i行的皇后应该放在第n列。

皇后的行、列编号都是从1开始算。

样例输入:

4

样例输出:

2 4 1 3 

3 1 4 2





### 逆波兰表达式

- 用递归解决递归形式的问题

```

```

例题:逆波兰表达式

​        逆波兰表达式是一种把运算符前置的算术表达式(其实一般教科书上称这种表 达式为波兰表达式) ，例如普通的表达式2 + 3的逆波兰表示法为+ 2 3。逆波兰 表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如 (2 + 3) * 4的逆波兰表示法为* + 2 3 4。本题求解逆波兰表达式的值，其中运算符 包括+ - * /四个。

- 输入

  输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点 数

- 输出

输出为一行，表达式的值。

- 样例输入
  * + 11.0 12.0 + 24.0 35.0

- 样例输出
  - 1357.000000 提示:(11.0+12.0)*(24.0+35.0)



> 本题中“逆波兰表达式”的定义:
>
> \1) 一个数是一个逆波兰表达式，值为该数
>
> \2) "运算符 逆波兰表达式 逆波兰表达式" 是逆波兰表达 式 ，值为两个逆波兰表达式的值运算的结果

### 四则运算表达式求值

输入为四则运算表达式，仅由整数、+、-、*、/ 、(、) 组成，没有空格，要求求其值。假设运算符结果都是整数 。"/"结果也是整数

```c
/** 表达式求值

 \* 输入一个表达式，对表达式进行求值

 \* 分解：表达式分解为项和因子，表达式是由多个项进行加减得到，项是因子间乘除得到

 \* so 需要写一个求项的值的函数

 \*         一个求因子的值的函数

 \*         一个求表达式的值的函数

 \* 

 \* 

 \* */
void ExperessionVal();
int exp_val();
```





### 爬楼梯

- 用递归将问题分解为规模更小的子问题进行求解

树老师爬楼梯，他可以每次走1级或者2级，输入楼梯的级数， 求不同的走法数

- 输入

输入包含若干行，每行包含一个正整数N，代表楼梯级数，1 <= N <= 30输出不同的走法数，每一行输入对应一行

- 输出

不同的走法数，每一行输入对应一行输出

样例输入

5

8

10 

样例输出 

8

34

89

```c
/**
 n级台阶的走法 =
	先走一级后，n-1级台阶的走法 + 先走两级后，n-2级台阶的走法
	f(n) = f(n-1)+f(n-2)
	边界条件：n  < 0 f = 0; n = 0; f = 1;
*/
int Stairs(int n);
```



### 例题:放苹果

把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放， 问共有多少种不同的分法?5，1，1和1，5，1 是同一种分法。
 输入
 第一行是测试数据的数目t(0 <= t <= 20)。以下每行均包含二个整 数M和N，以空格分开。1<=M，N<=10。

输出

对输入的每组数据M和N，用一行输出相应的K。

样例输入

1
73 

样例输出 8





### 算24

n个数算24，必有两个数要先算。这两个数算的结果，和剩余n-2个数，就构成了n-1个数求24的问题 

枚举先算的两个数，以及这两个数的运算方式。

边界条件:一个数算24 注意:浮点数比较是否相等，不能用 ==



## 二分算法

### 二分查找

> 写一个函数BinarySeach，在包含size个元素的、从小到大排序的int数组a里查找元素p,如果找到，则返回元素下标，如果找不到，则返回-1。要求复杂度O(log(n))



### LowerBound

写一个函数LowerBound，在包含size个元素的、从小到大排序的int数组a里查找比给

定整数p小的，下标最大的元素。找到则返回其下标，找不到则返回-1

## 分治

### 基本概念

 把一个任务，分成形式和原任务相同，但规模更小的 几个部分任务(通常是两个部分)，分别完成，或只 需要选一部完成。然后再处理完成后的这一个或几个 部分的结果，实现整个任务的完成。

### 分治的典型应用-归并排序

数组排序任务可以如下完成:
 \1) 把前一半排序
 \2) 把后一半排序
 \3) 把两半归并到一个新的有序数组，然后再拷贝回原 数组，排序完成。

```c
MergeSort();
```

#### 时间复杂度

对n个元素进行排序的时间:

T(n) = 2*T(n/2) + a*n
 = 2*(2*T(n/4)+a*n/2)+a*n

= 4*T(n/4)+2a*n
 = 4*(2*T(n/8)+a*n/4)+2*a*n = 8*T(n/8)+3*a*n
 ...
 = 2k *T(n/2k)+k*a*n

(a是常数,具体多少不重要)

一直做到 n/2k = 1 (此时 k = log2n)，
 T(n)= 2k *T(1)+k*a*n = 2k *T(1)+k*a*n = 2k+k*a*n

= n+a*(log2n)*n 复杂度O(nlogn)

### 快速排序

数组排序任务可以如下完成:

1. 设k=a[0], 将k挪到适当位置，使得比k小的元素都 在k左边,比k大的元素都在k右边，和k相等的，不关心 在k左右出现均可 (O(n)时间完成)

2) 把k左边的部分快速排序
3) 把k右边的部分快速排序

```c
void swap(int &a, int &b); // 交换a b的值
 
void QuickSort(int a[],int s,int e); // 快速排序
```

